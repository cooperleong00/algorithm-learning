# 最短路算法
  通常比较常用的最短路算法有三种：Dijsktra、Floyd 和 Bellman-Ford算法 (A* 算法？)。
## Dijsktra
### 性质
- Dijkstra 的结果是一棵从起点到图中剩余所有点的最短路径树（SPT）
- 最短路径不一定是唯一的
- Dijkstra不能处理负权重
- 普通Dijkstra的时间复杂度为O(V^2)，经过堆优化可以达到O((E+V)log(V))(二叉堆) 以及 O(E+Vlog(V))(斐波那契堆)

### 描述
   已知起点s，我们使用一个记录当前最短路径的数组dis[], 其中dis[i]表示当前从s到i的路径距离是多少；以及一个vis[]，vis[i]=0表示还没迭代过i的所有邻接点。首先将dis[] 全部初始化为inf，而起点初始化为0(自己到自己距离为0)。然后第一次迭代会更新起点的所有点的距离，因为邻接点间都只有一条边，因此一定都是最短距离，同时我们在这一次迭代前把s标记为迭代过。然后我们选一个还没迭代过的，离起点s距离最小的点假设为n，我们再迭代n的所有邻接点；如果对于n的某一个没被迭代过的邻接点m（因为迭代过的点一定已经是距离最短，无需再访问），我们发现从s走到n走到m，比从s到其他点再到m，距离更短，我们就把m的当前最短距离更新成这条从n走再到m的距离，也就是s到n的距离加上n到m的距离；如果需要记录路径，则将m的上一节点更新为n。如此迭代下去，到所有的节点都被迭代过了，从s到其他点的最短距离也就都确定了。


## Floyd

### 一个通俗易懂的证明
https://blog.csdn.net/ljhandlwt/article/details/52096932#commentBox
